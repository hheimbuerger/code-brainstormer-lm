# Code-Brainstormer LM – Project Overview

_Last updated 2025-08-05 by Cascade assistant_

## What is Code-Brainstormer LM?
Code-Brainstormer LM is an **interactive playground for designing, visualising and iterating on structured programming code in collaboration with an LLM**.

As the user is conducting the architecture brainstorming with the LLM, the visual model is mirrored into a shadow code repository—a live, synchronized code structure generated from the diagram, not merely backed by code.

* sketch new function APIs and project structures in minutes,
* explore alternative function decompositions,
* auto-generate stub implementations / documentation,
* see live call-graph edges between functions, and
* persist or export the result as code.

In short, it is "LLM-augmented Figma for early-stage code architecture."

## Domain model

The project focuses on function-based structured programming, visualizing how functions interact with each other within a project context.

Each function is represented as a node with four separate aspects:

* identifier: the function name
* signature: the function parameters and return types
* specification: the description of the function, use cases and internal logic, think the function's docstring
* implementation: primarily a textual description of the function's logic, including a complete list of all function calls it can invoke.

The project also includes an editable project name that serves as the main identifier for the codebase.

## Code Generation

The first three aspects can be edited by the user. Each time the user edits one of these, the LLM is asked to update the next one based on the edit, unless locked down.
The implementation is always generated by the LLM, and can only be influenced via the specification.

## Key Building Blocks
| Layer | Folder(s) | Purpose |
|-------|-----------|-------|
| **Domain Model** | `store/`, `data/` | `CodeAspect`, `CodeFunction` represent descriptors, signatures, specs & implementations. Zustand holds the authoritative state with `projectName` and `codeFunctions`. Example data ships in `data/example-project.json`. |
| **Visual Editor** | `components/ProjectCanvas/` | A unified React-Flow canvas (`ProjectCanvas.tsx`) that integrates project banner and function diagram. Maps each `CodeFunction` to a node (`FunctionNode.tsx`). Edges are auto-derived from inline function calls in the implementation text. Users can drag nodes; edges recalc on drop. |
| **Data Persistence** | `data/` | Unified JSON schema (`projectSchema.ts`) and loader/saver (`dataLoader.ts`) supporting both sample data and full UI state persistence. |
| **Next.js App** | `app/` | Thin App-Router shell that provides `ReactFlowProvider` and hosts the ProjectCanvas full-screen. |
| **Docs** | `docs/` | Architectural notes (`architecture_data_model.md`) and this overview. |

## Current Feature Set
1. **Project Management**: Editable project name with click-to-edit functionality in the integrated banner.
2. **Function Visualization**: Load example projects with multiple functions in a visual canvas.
3. **Inline Editing**: Edit identifiers, signatures, specifications and implementation snippets directly inside each function node.
4. **Smart Call Graph**: Automatic call-graph edge creation with smart handle positioning (nearest side) based on function calls in implementation text.
5. **Unified Persistence**: Support for both minimal sample data and full UI state persistence with automatic UI generation.
6. **State Management**: Lightweight state management via Zustand dev-tooled store (`useCodebaseStore`) with function-based data model.
7. **React-Flow Integration**: Background grid, zoom controls, drag-and-drop nodes, and panel help text.
8. **LLM Code Generation**: Backend integration for progressive code generation with aspect-based workflow.

## Planned / Envisioned Features
* **LLM integration** to suggest method lists, refactor signatures, or generate skeleton code from specs.
* **Persistence** of custom layouts (`saveGraph`) and multi-diagram support per class or module.
* **Exporters**: generate real Java / TypeScript files or documentation from the domain model.
* **Collaboration**: shareable links or real-time editing via WebSockets.

## Typical Use Cases
1. **Architecture Brainstorming** – Quickly sketch a new service layer, discuss with the team, and iterate visually.
2. **Workshop / Teaching Aid** – Demonstrate clean decomposition and call-graph thinking to students or juniors.
3. **Spike Prototyping** – Validate an algorithm breakdown with auto-generated stubs before committing to a repo.
4. **Doc-as-Code** – Keep high-level design docs (specs, signatures) in sync with implementation through exports.

## Tech Stack at a Glance
* **TypeScript 5**
* **Next.js 14 / App Router / client components**
* **React-Flow 11** for graph UI
* **Zustand 5** (+ devtools) for state
* **Vite** dev server (via default Next config)

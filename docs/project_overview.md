# Code-Brainstormer LM – Project Overview

_Last updated 2025-07-11 by Cascade assistant_

## What is Code-Brainstormer LM?
Code-Brainstormer LM is an **interactive playground for designing, visualising and iterating on object-oriented code in collaboration with an LLM**.

As the user is conducting the architecture brainstorming with the LLM, the visual model is mirrored into a shadow code repository—a live, synchronized code structure generated from the diagram, not merely backed by code.

* sketch a new class or service API in minutes,
* explore alternative method decompositions,
* auto-generate stub implementations / documentation,
* see live call-graph edges between methods, and
* persist or export the result as code.

In short, it is “LLM-augmented Figma for early-stage code architecture.”

## Domain model

The project looks at the visual diagram for a single class, how its methods interact with each other, and to a limited amount how they interact with the outside world.

Each method is represented as a node with four separate aspects:

* identifier: the method name
* signature: the method parameters and return types
* specification: the description of the method, use cases and internal logic, think the method's docstring
* implementation: primarily a textual description of the method's logic, including a complete list of all method calls it can invoke.

## Code Generation

The first three aspects can be edited by the user. Each time the user edits one of these, the LLM is asked to update the next one based on the edit, unless locked down.
The implementation is always generated by the LLM, and can only be influenced via the specification.

## Key Building Blocks
| Layer | Folder(s) | Purpose |
|-------|-----------|---------|
| **Domain Model** | `store/`, `data/` | `CodeAspect`, `CodeMethod`, `CodeClass` represent descriptors, signatures, specs & implementations.  Zustand holds the authoritative state.  Example data ships in `data/generated-code-example.ts`. |
| **Visual Editor** | `components/FlowDiagram/` | A React-Flow canvas that maps each `CodeMethod` to a node (`MethodNode.tsx`).  Edges are auto-derived from inline function calls in the implementation text.  Users can drag nodes; edges recalc on drop. |
| **Next.js App** | `app/` | Thin App-Router shell that provides `ReactFlowProvider` and hosts the diagram full-screen. |
| **Docs** | `docs/` | Architectural notes (`architecture_data_model.md`) and this overview. |

## Current Feature Set
1. Load an example class with three methods + external dependencies.
2. Edit identifiers, signatures, specifications and implementation snippets directly inside each node.
3. Automatic call-graph edge creation with smart handle positioning (nearest side).
4. Lightweight state management via Zustand dev-tooled store (`useCodebaseStore`).
5. React-Flow extras: background grid, zoom controls, panel help text.

## Planned / Envisioned Features
* **LLM integration** to suggest method lists, refactor signatures, or generate skeleton code from specs.
* **Persistence** of custom layouts (`saveGraph`) and multi-diagram support per class or module.
* **Exporters**: generate real Java / TypeScript files or documentation from the domain model.
* **Collaboration**: shareable links or real-time editing via WebSockets.

## Typical Use Cases
1. **Architecture Brainstorming** – Quickly sketch a new service layer, discuss with the team, and iterate visually.
2. **Workshop / Teaching Aid** – Demonstrate clean decomposition and call-graph thinking to students or juniors.
3. **Spike Prototyping** – Validate an algorithm breakdown with auto-generated stubs before committing to a repo.
4. **Doc-as-Code** – Keep high-level design docs (specs, signatures) in sync with implementation through exports.

## Tech Stack at a Glance
* **TypeScript 5**
* **Next.js 14 / App Router / client components**
* **React-Flow 11** for graph UI
* **Zustand 5** (+ devtools) for state
* **Vite** dev server (via default Next config)
